import Data.List
import Data.Char
import Data.Foldable
import Data.Maybe



--PART 1
-- (a)
{-
Discussion : Takes list of type a and returns Maybe a. Works by a left fold. Arguments
of this left fold are a lambda, Nothing (base case) and tail of input list. The lambda
doesn't accumulate anything and results in Just head (curr) which at end of list
is the foot.
-}
safeFoot :: [a] -> Maybe a
safeFoot (s) = foldl (\_ curr -> Just curr) Nothing s

-- Tests sample correct input
t1a0 = safeFoot([1,2,3]) == Just 3
-- Tests incorrect
t1a1 = not (safeFoot([1,2,3]) == Just 4)
-- Test single element
t1a2 = safeFoot(["dog"]) == Just "dog"
-- Run test for (a)
t1a = [t1a0,t1a1,t1a2]


-- (b)
{-
Discussion : Convert takes a String and returns an Int. Uses a left fold which has
a lambda, a base case of 0 and a String of an Int. The lambda accumaltates the
current head, converted to an Int, multiplied by 10.
-}
convert :: String -> Int
convert st = foldl (\sofar x -> 10 * sofar + digitToInt x) 0 st

-- Test sampe input
t1b0 = convert "1234" == 1234
-- Test base case
t1b1 = convert "" == 0
-- Runs tests for (b)
t1b = [t1b0,t1b1]


-- (c)
{-
Discussion : elel takes a target of type a and a list of type a as arguemnts. It
returns a Bool. It works by first mapping the input list to a list of Bool
where each element is False if not equal to target and True if equal to target.
This new list is then fold with a lambda which logically ORS the accumulation with
the head. Effectively reducing it to False if no True exists in list or True if a
True exists in the list.
-}
elel :: Eq a => a -> [a] -> Bool
elel target list = foldl (\x acc -> x || acc) False (map (\x -> if x == target then True else False) list)

-- Tests sample input
t1c0 = elel 3 [1,2,3,4,5] == True
-- Test input of different type
t1c1 = elel "rabbit" ["cat","dog","rabbit"] == True
-- Test something not in list
t1c2 = elel 6 [1,2,3,4,5] == False
-- Runs tests in (c)
t1c = [t1c0,t1c1,t1c2]


-- (d) Use one fold to average a list. ----- BIT SCUFFED NO NOTHING
{-
Discussion : Takes a list of Double as argument and returns Maybe Double. Works
by diving a sum of input list by length of input list. The sum is found using
a fold with function (+).
-}
average :: [Double] -> Maybe Double
average list = Just ((/) (foldl (+) 0 list) (fromIntegral(length list)))

-- Tests sample input
t1d0 = average [1.0,2.0,3.0,4.0] == Just 2.5
-- Tests single
t1d1 = average [1] == Just 1
-- Runs all tests for (d)
t1d = [t1d0,t1d1]


-- (e)
{-
-- Discussion : Take a list of (Month,Int) tuples and a day and returns a list of
(Day,Int,Month) tuples. Works by zipping a cycle of the days, beginning at the given day with
an array of tuples containing month and day number. The result is then formatted
into output list ysing 'snd' and 'fst' commands of tuples.
The array of tuples containing month and day number are generated by zipping a cycle of
the month of a tuple with the array [1..length_of_month] (each tupple taken from input list)
-}
data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun  deriving (Enum,Show,Eq)
data Month = Jan | Feb | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov | Dec deriving (Enum,Show,Eq)

--calendar :: [(Month, Int)] -> Day -> [(Day, Int, Month)]
calendar tuplelist day = [ (snd t,fst(fst t),snd(fst t)) | t <- zip (concat [([ c | c <- zip [1..snd tuple] (cycle [fst tuple])]) | tuple <- tuplelist]) ([day ..] ++ (cycle  [Mon .. ]))]

-- Tests sample input
t1e0 = (calendar [(Jan, 1), (Feb, 2)] Tue) == ([(Tue,1,Jan),(Wed,1,Feb),(Thu,2,Feb)])
-- Tests calendar 2020
  -- Calendar Prediction
t1e1_predict = (calendar [(Jan,31),(Feb,29),(Mar,31),(Apr,30),(May,31),(Jun,30),(Jul,31),(Aug,31),(Sep,30),(Oct,31),(Nov,30),(Dec,31)] Wed)
  -- Actual 2020 calendar in output format
calendar_2020 = [(Wed,1,Jan),(Thu,2,Jan),(Fri,3,Jan),(Sat,4,Jan),(Sun,5,Jan),(Mon,6,Jan),(Tue,7,Jan),(Wed,8,Jan),(Thu,9,Jan),(Fri,10,Jan),(Sat,11,Jan),(Sun,12,Jan),(Mon,13,Jan),(Tue,14,Jan),(Wed,15,Jan),(Thu,16,Jan),(Fri,17,Jan),(Sat,18,Jan),(Sun,19,Jan),(Mon,20,Jan),(Tue,21,Jan),(Wed,22,Jan),(Thu,23,Jan),(Fri,24,Jan),(Sat,25,Jan),(Sun,26,Jan),(Mon,27,Jan),(Tue,28,Jan),(Wed,29,Jan),(Thu,30,Jan),(Fri,31,Jan),(Sat,1,Feb),(Sun,2,Feb),(Mon,3,Feb),(Tue,4,Feb),(Wed,5,Feb),(Thu,6,Feb),(Fri,7,Feb),(Sat,8,Feb),(Sun,9,Feb),(Mon,10,Feb),(Tue,11,Feb),(Wed,12,Feb),(Thu,13,Feb),(Fri,14,Feb),(Sat,15,Feb),(Sun,16,Feb),(Mon,17,Feb),(Tue,18,Feb),(Wed,19,Feb),(Thu,20,Feb),(Fri,21,Feb),(Sat,22,Feb),(Sun,23,Feb),(Mon,24,Feb),(Tue,25,Feb),(Wed,26,Feb),(Thu,27,Feb),(Fri,28,Feb),(Sat,29,Feb),(Sun,1,Mar),(Mon,2,Mar),(Tue,3,Mar),(Wed,4,Mar),(Thu,5,Mar),(Fri,6,Mar),(Sat,7,Mar),(Sun,8,Mar),(Mon,9,Mar),(Tue,10,Mar),(Wed,11,Mar),(Thu,12,Mar),(Fri,13,Mar),(Sat,14,Mar),(Sun,15,Mar),(Mon,16,Mar),(Tue,17,Mar),(Wed,18,Mar),(Thu,19,Mar),(Fri,20,Mar),(Sat,21,Mar),(Sun,22,Mar),(Mon,23,Mar),(Tue,24,Mar),(Wed,25,Mar),(Thu,26,Mar),(Fri,27,Mar),(Sat,28,Mar),(Sun,29,Mar),(Mon,30,Mar),(Tue,31,Mar),(Wed,1,Apr),(Thu,2,Apr),(Fri,3,Apr),(Sat,4,Apr),(Sun,5,Apr),(Mon,6,Apr),(Tue,7,Apr),(Wed,8,Apr),(Thu,9,Apr),(Fri,10,Apr),(Sat,11,Apr),(Sun,12,Apr),(Mon,13,Apr),(Tue,14,Apr),(Wed,15,Apr),(Thu,16,Apr),(Fri,17,Apr),(Sat,18,Apr),(Sun,19,Apr),(Mon,20,Apr),(Tue,21,Apr),(Wed,22,Apr),(Thu,23,Apr),(Fri,24,Apr),(Sat,25,Apr),(Sun,26,Apr),(Mon,27,Apr),(Tue,28,Apr),(Wed,29,Apr),(Thu,30,Apr),(Fri,1,May),(Sat,2,May),(Sun,3,May),(Mon,4,May),(Tue,5,May),(Wed,6,May),(Thu,7,May),(Fri,8,May),(Sat,9,May),(Sun,10,May),(Mon,11,May),(Tue,12,May),(Wed,13,May),(Thu,14,May),(Fri,15,May),(Sat,16,May),(Sun,17,May),(Mon,18,May),(Tue,19,May),(Wed,20,May),(Thu,21,May),(Fri,22,May),(Sat,23,May),(Sun,24,May),(Mon,25,May),(Tue,26,May),(Wed,27,May),(Thu,28,May),(Fri,29,May),(Sat,30,May),(Sun,31,May),(Mon,1,Jun),(Tue,2,Jun),(Wed,3,Jun),(Thu,4,Jun),(Fri,5,Jun),(Sat,6,Jun),(Sun,7,Jun),(Mon,8,Jun),(Tue,9,Jun),(Wed,10,Jun),(Thu,11,Jun),(Fri,12,Jun),(Sat,13,Jun),(Sun,14,Jun),(Mon,15,Jun),(Tue,16,Jun),(Wed,17,Jun),(Thu,18,Jun),(Fri,19,Jun),(Sat,20,Jun),(Sun,21,Jun),(Mon,22,Jun),(Tue,23,Jun),(Wed,24,Jun),(Thu,25,Jun),(Fri,26,Jun),(Sat,27,Jun),(Sun,28,Jun),(Mon,29,Jun),(Tue,30,Jun),(Wed,1,Jul),(Thu,2,Jul),(Fri,3,Jul),(Sat,4,Jul),(Sun,5,Jul),(Mon,6,Jul),(Tue,7,Jul),(Wed,8,Jul),(Thu,9,Jul),(Fri,10,Jul),(Sat,11,Jul),(Sun,12,Jul),(Mon,13,Jul),(Tue,14,Jul),(Wed,15,Jul),(Thu,16,Jul),(Fri,17,Jul),(Sat,18,Jul),(Sun,19,Jul),(Mon,20,Jul),(Tue,21,Jul),(Wed,22,Jul),(Thu,23,Jul),(Fri,24,Jul),(Sat,25,Jul),(Sun,26,Jul),(Mon,27,Jul),(Tue,28,Jul),(Wed,29,Jul),(Thu,30,Jul),(Fri,31,Jul),(Sat,1,Aug),(Sun,2,Aug),(Mon,3,Aug),(Tue,4,Aug),(Wed,5,Aug),(Thu,6,Aug),(Fri,7,Aug),(Sat,8,Aug),(Sun,9,Aug),(Mon,10,Aug),(Tue,11,Aug),(Wed,12,Aug),(Thu,13,Aug),(Fri,14,Aug),(Sat,15,Aug),(Sun,16,Aug),(Mon,17,Aug),(Tue,18,Aug),(Wed,19,Aug),(Thu,20,Aug),(Fri,21,Aug),(Sat,22,Aug),(Sun,23,Aug),(Mon,24,Aug),(Tue,25,Aug),(Wed,26,Aug),(Thu,27,Aug),(Fri,28,Aug),(Sat,29,Aug),(Sun,30,Aug),(Mon,31,Aug),(Tue,1,Sep),(Wed,2,Sep),(Thu,3,Sep),(Fri,4,Sep),(Sat,5,Sep),(Sun,6,Sep),(Mon,7,Sep),(Tue,8,Sep),(Wed,9,Sep),(Thu,10,Sep),(Fri,11,Sep),(Sat,12,Sep),(Sun,13,Sep),(Mon,14,Sep),(Tue,15,Sep),(Wed,16,Sep),(Thu,17,Sep),(Fri,18,Sep),(Sat,19,Sep),(Sun,20,Sep),(Mon,21,Sep),(Tue,22,Sep),(Wed,23,Sep),(Thu,24,Sep),(Fri,25,Sep),(Sat,26,Sep),(Sun,27,Sep),(Mon,28,Sep),(Tue,29,Sep),(Wed,30,Sep),(Thu,1,Oct),(Fri,2,Oct),(Sat,3,Oct),(Sun,4,Oct),(Mon,5,Oct),(Tue,6,Oct),(Wed,7,Oct),(Thu,8,Oct),(Fri,9,Oct),(Sat,10,Oct),(Sun,11,Oct),(Mon,12,Oct),(Tue,13,Oct),(Wed,14,Oct),(Thu,15,Oct),(Fri,16,Oct),(Sat,17,Oct),(Sun,18,Oct),(Mon,19,Oct),(Tue,20,Oct),(Wed,21,Oct),(Thu,22,Oct),(Fri,23,Oct),(Sat,24,Oct),(Sun,25,Oct),(Mon,26,Oct),(Tue,27,Oct),(Wed,28,Oct),(Thu,29,Oct),(Fri,30,Oct),(Sat,31,Oct),(Sun,1,Nov),(Mon,2,Nov),(Tue,3,Nov),(Wed,4,Nov),(Thu,5,Nov),(Fri,6,Nov),(Sat,7,Nov),(Sun,8,Nov),(Mon,9,Nov),(Tue,10,Nov),(Wed,11,Nov),(Thu,12,Nov),(Fri,13,Nov),(Sat,14,Nov),(Sun,15,Nov),(Mon,16,Nov),(Tue,17,Nov),(Wed,18,Nov),(Thu,19,Nov),(Fri,20,Nov),(Sat,21,Nov),(Sun,22,Nov),(Mon,23,Nov),(Tue,24,Nov),(Wed,25,Nov),(Thu,26,Nov),(Fri,27,Nov),(Sat,28,Nov),(Sun,29,Nov),(Mon,30,Nov),(Tue,1,Dec),(Wed,2,Dec),(Thu,3,Dec),(Fri,4,Dec),(Sat,5,Dec),(Sun,6,Dec),(Mon,7,Dec),(Tue,8,Dec),(Wed,9,Dec),(Thu,10,Dec),(Fri,11,Dec),(Sat,12,Dec),(Sun,13,Dec),(Mon,14,Dec),(Tue,15,Dec),(Wed,16,Dec),(Thu,17,Dec),(Fri,18,Dec),(Sat,19,Dec),(Sun,20,Dec),(Mon,21,Dec),(Tue,22,Dec),(Wed,23,Dec),(Thu,24,Dec),(Fri,25,Dec),(Sat,26,Dec),(Sun,27,Dec),(Mon,28,Dec),(Tue,29,Dec),(Wed,30,Dec),(Thu,31,Dec)]
  -- Test to see if prediction and actual are the same
t1e1 = t1e1_predict == calendar_2020
-- Runs all tests for (e)
t1e = [t1e0,t1e1]

-- Runs all tests for part 1
t1 = [t1a,t1b,t1c,t1d,t1e]
-----------------------------------------------------------------------------------------------------------------------------------

-- PART 2
-- BinTree
data BinTree a = Empty | Node a (BinTree a) (BinTree a) deriving (Eq,Show)

-- A few differnet trees for testing :
tree_1 = (Node 5 (Node 2 Empty Empty) (Node 9 (Node 7 Empty Empty) Empty))
tree_2 = (Node 5 (Node 2 Empty Empty) (Node 9 Empty Empty))
tree_3 = (Node 5 (Node 7 Empty Empty) Empty )
tree_4 = (Node 5 (Node 6 (Node 7 (Node 8 Empty Empty) Empty) Empty) Empty)
tree_5 = Node 5 Empty Empty
tree_6 = Empty


-- (a)
{-
Discussion : btcata applies a function to a binary tree. It works recursively
applying the function as it comes back up the tree. The function is applied
to three things; the current node label, the left tree accumulator and the
right tree accumulator.
-}
btcata :: (t1 -> t2 -> t2 -> t2) -> t2 -> BinTree t1 -> t2
-- Base Case
btcata func z Empty = z
-- Recurisve Case
btcata func acc (Node x left right) = func x (btcata func acc left) (btcata func acc right)

-- Test simple tree
t2a0 = btcata (\x y z -> x + 1) 0 tree_5 == 6
-- Test empty tree - base case
t2a1 = btcata (\x y z -> x + 1) 0 tree_6 == 0
-- Test function sum applied to large trees
t2a2 = btcata (\x y z -> x + y + z) 0 tree_1 == 23
-- Run all tests for (a)
t2a = [t2a0,t2a1,t2a2]


-- (b)
{-
Discussion : btsize takes a BinTree with nodes of type a as an arguemnt. It returns an Int.
This Int is the count of the number of nodes. btsize uses btcata and a lambda to
calculate it's result. The lambda takes three arguments and it's result is the
1 + the sum of the second 2 arguments. These second 2 arguemnts are the count
of the left binary tree and the count of theright binary tree
-}
btsize :: BinTree a -> Int
btsize bt = btcata (\u v w -> 1 + v + w) 0 bt

-- Tests on single node tree
t2b0 = btsize tree_5 == 1
-- Tests on empty trees
t2b1 = btsize tree_6 == 0
-- Tests on large tree
t2b2 = btsize tree_1 == 4
-- Runs all tests for (b)
t2b = [t2b0,t2b1,t2b2]


-- (c)
{-
Discussion : btsum takes a BinTree with node/label of type Num and returns a Num. This returned
Num is the sum of all the tree labels. btsume uses btcata and a lambda to calculate
it's result. The lambda takes three arguments and it's result is the sum of the
three arguments. The first argument is the new label, the seocnd is the sum of
the left binary tree and the third is the sum of the right binary tree
-}
btsum :: Num n => BinTree n -> n
btsum bt = btcata (\u v w -> u + v + w) 0 bt

-- Tests on single node tree
t2c0 = btsum tree_5 == 5
-- Tests on empty trees
t2c1 = btsum tree_6 == 0
-- Tests on large tree
t2c2 = btsum tree_1 == 23
-- Runs all tests on (c)
t2c = [t2c0,t2c1,t2c2]


-- (d)
{-
Assuming : length (Node 5 Empty Empty) == 1 and length(Empty) == 0
Discussion : btheight takes a BinTree of type a and returns an Int. This int is
the max height of the tree. It works using a lambda which takes 3 inputs.
It ignores the first, then adds 1 to the larger of the second two
-}
btheight :: BinTree a -> Int
btheight bt = btcata (\u v w -> if v > w then v + 1 else w + 1) 0 bt
--main = print(btheight t)

-- Tests on single node tree
t2d0 = btheight tree_5 == 1
-- Tests on empty trees
t2d1 = btheight tree_6 == 0
-- Tests on large tree
t2d2 = btheight tree_1 == 3
-- Tests very asymetrical trees
t2d3 = btheight tree_4 == 4
-- Runs all test on (d)
t2d = [t2d0,t2d1,t2d2,t2d3]


-- (e)
{-
Discussion : btreflect takes a BinTree a as input and out puts BinTree a.
It returns the mirror the binary tree that was inputed. It works by recursively applying
a lambda from the bottum up to the tree. The lambda creates a new node which has
the label of the current node but switches the left and right tree around.
-}
btreflect :: BinTree a -> BinTree a
btreflect bt = btcata (\u v w -> Node u w v) Empty bt

-- Test symmterical tree test
t2e0 = btreflect tree_5 == Node 5 Empty Empty
-- Test on large tree
t2e1 = btreflect tree_1 == Node 5 (Node 9 Empty (Node 7 Empty Empty)) (Node 2 Empty Empty)
-- Run all tests for (e)
t2e = [t2e0,t2e1]


-- (f)
{-
Discussion : Takes two arguemtns, of type a (target) and BinTree a. It returns a boolean
True if the first argument is contained in the second arguements. It works with lambda
that has three arguments; node label, boolean left tree , boolean right tree. It
is True if either the left or right tree is true or if the target equals the current8
label.
-}
bthas :: Eq a => a -> BinTree a -> Bool
bthas target bt = btcata (\u v w -> if u == target || v == True || w == True then True else False) False bt

-- Test on small trees
t2f0 = bthas 5 tree_5 == True
-- Test on large tree
t2f1 = bthas 7 tree_1 == True
-- Tests on value not in trees
t2f2 = bthas 711 tree_5 == False
-- Run all tests in (f)
t2f = [t2f0,t2f1,t2f2]


-- (g)
{-
Discussion : Allows foldr to be used on BinTree. Recurisve depth first search
of the binary tree. Takes three arguments: function, base and and BinTree. Base
case of foldr defniition takes Empty as 3rd argument.
-}
instance Foldable BinTree where
  foldr f z Empty = z
  foldr f acc (Node v l r) = foldr f (f v (foldr f acc r)) l

-- Test no error thrown
t2g0 = foldr (\u v -> u) 0 tree_1 == 2
-- Test basic foldr against btsum (btcata)
t2g1 = foldr (\u v -> u + v) 0 tree_1 == btsum tree_1
-- Run all tests for (g)
t2g = [t2g0,t2g1]


-- (h) :
{-
foldr can't be defined using btcata because of how they traverse the tree.
foldr uses a depth first traversal, moving right then backtracking for left.
btcata does (not sure the exact name for this) a breadth first bottom up traversal.
For a function like btsize this doesn't matter BUT if the function was appending
to a list the results would be different. Therefor foldr cannot use btcata in it's
definition.

btcata name = binary tree catamorpishm. a catamophism is "a universal abstraction
that describes how to digest a data structure into a potentially momre compact value".
-}

-- Run all PART 2 tests
t2 = [t2a,t2b,t2c,t2d,t2e,t2f,t2g]
----------------------------------------------------------------------------------------------

-- PART 3
-- (a)
{-
Discussion : My data type WFF is used to represent propisition well formed
formulae. It works recrusively with the base being algerbraic variables P Q R.
The recrusion occurs on all logical connectives where the connective is applied
to another WFF.
For example :
Neg (Neg (Neg P)) -> This is a recursive WFF with the full equation, the inner
and the inner inner aand the P all being WFF.
Con P (Neg Q) -> Once again Con takes 2 WFF. P is a WFF and (Neg Q) is a WFF.
Also Q is a WFF.
-}
data WFF = Neg WFF | Con WFF WFF | Dis WFF WFF | Imp WFF WFF | Equ WFF WFF | P | Q | R deriving (Eq)


-- (b)
{-
Discussion : all the below functions are for formulating the WFF from an input.
They all pretty simple so I feel they don't need much discussion. From an input
they create a recusively structured WFF
-}
-- Takes a char and returns a WFF of the correct char
var :: Char -> WFF
var a = if a == 'r' then R else (if a == 'p' then P else Q)
-- basic test for var
t3b0 = var 'r' == R

-- Takes a WFF and returns a WFF : Neg WFF
neg :: WFF -> WFF
neg a = Neg a
-- basic test for neg
t3b1 = neg (var 'r') == Neg R

-- Takes two WFF and return one WFF : Con WFF WFF
con :: WFF -> WFF -> WFF
con a b = Con a b
-- basic test for con
t3b2 = con (var 'r') (var 'r') == Con R R

-- Takes two WFF and return one WFF : Dis WFF WFF
dis :: WFF -> WFF -> WFF
dis a b = Dis a b
-- basic test for dis
t3b3 = dis (var 'r') (var 'r') == Dis R R

-- Takes two WFF and return one WFF : Equ WFF WFF
equ :: WFF -> WFF -> WFF
equ a b = Equ a b
-- basic test for equ
t3b4 = equ (var 'r') (var 'r') == Equ R R

-- Takes two WFF and return one WFF : Imp WFF WFF
imp :: WFF -> WFF -> WFF
imp a b = Imp a b
-- basic test for imp
t3b5 = imp (var 'r') (var 'r') == Imp R R

-- Run all tests for (b)
t3b = [t3b0,t3b1,t3b2,t3b3,t3b4,t3b5]


-- (c)
{-
Discussion : This code makes WFF an instnce of typeclass Show so that printing
a WFF will print in the desied format. Recursively calls it self to print
everything correctly. Base cases are the variables.
-}
instance Show WFF where
  show P = "p"
  show Q = "q"
  show R = "r"
  show (Neg x) = "!(" ++ show x ++ ")"
  show (Con x y) = "(" ++ (show x) ++ "&&" ++ (show y) ++ ")"
  show (Dis x y) = "(" ++ (show x) ++ "||" ++ (show y) ++ ")"
  show (Imp x y) = "(" ++ (show x) ++ "==>" ++ (show y) ++ ")"
  show (Equ x y) = "(" ++ (show x) ++ "==" ++ (show y) ++ ")"

-- Tests the sample input from the assignment brief
t3c0 = show ((con (imp (con (var 'p')(var 'q')) (var 'r')) (imp (var 'r') (var 'q')))) == "(((p&&q)==>r)&&(r==>q))"
-- Tests first sample from question
t3c1 = show(con (imp (var 'p') (var 'q')) (neg (imp (var 'q') (var 'r')))) == "((p==>q)&&!((q==>r)))"
-- Runs all tests in (c)
t3c = [t3c0,t3c1]


-- (d)
{-
Discussion : eval takes a WFF and a list of char bool tuples, which specify
variable assignment. It returns a maybe boolean type. It works by recrusively
preforming boolean operation on logical connectives until it reaches a base case of
a variable. Just base case is returned. For the recursive calls the just is removed
and then added to the combination using the commands fromJust and Just respecitively.
-}
eval :: WFF -> [(Char,Bool)] -> Maybe Bool
eval P va = Just (foldl (||) False [if fst v == 'p' then snd v else False | v <- va])
eval Q va = Just (foldl (||) False [if fst v == 'q' then snd v else False | v <- va])
eval R va = Just (foldl (||) False [if fst v == 'r' then snd v else False | v <- va])
eval (Neg x) va = Just (not (fromJust (eval x va)))
eval (Con x y) va = Just ((&&) (fromJust (eval x va)) (fromJust(eval y va)))
eval (Dis x y) va = Just ((||) (fromJust (eval x va)) (fromJust(eval y va)))
eval (Imp x y) va = Just ((<=) (fromJust (eval x va)) (fromJust(eval y va)))
eval (Equ x y) va = Just ((==) (fromJust (eval x va)) (fromJust(eval y va)))

-- Test valid input
t3d0 = fromJust (eval (con (var 'q') (var 'p')) ([('q',True),('p',True)])) == True
-- Test invalid input
t3d1 = fromJust (eval (con (var 'q') (var 'p')) ([('q',False),('p',False)])) == False
t3d2 = fromJust (eval (con (var 'q') (var 'p')) ([('q',True),('p',False)])) == False
t3d3 = fromJust (eval (con (var 'q') (var 'p')) ([('q',False),('p',True)])) == False
-- Runs all tests for (d)
t3d = [t3d0,t3d1,t3d2,t3d3]


-- (e)
{-
Discussion : free takes a WFF and returns a Char array of all unique variables.
Works by recursively appending the WFF with the base case being the variables.
nub function is applied to keep it unique. (nub [1,1] = [1])
-}
free :: WFF -> [Char]
free P = ['p']
free Q = ['q']
free R = ['r']
free (Neg x) = nub ([] ++ (free x))
free (Con x y) = nub ([] ++ (free x) ++ (free y))
free (Dis x y) = nub ([] ++ (free x) ++ (free y))
free (Imp x y) = nub ([] ++ (free x) ++ (free y))
free (Equ x y) = nub ([] ++ (free x) ++ (free y))

-- Test with 1 variable
t3e0 = length (free (var 'p')) == 1
-- Test with 2 variables
t3e1 = length (free (con (var 'p') (var 'q'))) == 2
-- Test with 3 variables
t3e2 = length (free (con (con (var 'p') (var 'q')) (var 'r'))) == 3
-- Runs all tests for (e)
t3e = [t3e0,t3e1,t3e2]


-- (f)
{-
Discussion : assignments takes a list of Char and returns all possible assignments.
(list of list of char,bool tuples). Uses a recursive assignment definition.
This question took me along time because I originally was just trying to solve it
using only list comprehension. The recursive idea is what fixed this for me.
-}
assignments :: [Char] -> [[(Char, Bool)]]
assignments [] = [[]]
assignments (curr:remain) = [(curr,True) : f | f <- assignments remain] ++ [(curr,False) : f | f <- assignments remain]

-- Test with 1 variable
t3f0 = length (assignments "p") == 2
-- Test with 2 variables
t3f1 = length (assignments "qp") == 4
-- Test with 3 variables
t3f2 = length (assignments "pqr") == 8
-- Runs all tests for (f)
t3f = [t3f0,t3f1,t3f2]


-- (g)
{-
Discussion : solve takes one paramater a WFF. It returns a list of list of char,bool
tuples that represents all possible inputs that can solve the WFF. It works using
the functions defined above. All assignments of the WFF are found using assignments
free wff. Then list comprehension adds to output list the assignment if the evaluation
of the assignment is true, else it adds empty list. Finally all empty lists are filtered out
-}

solve :: WFF -> [[(Char,Bool)]]
solve wff = filter (/= []) [if (fromJust (eval wff x)) then x else []  | x <- (assignments (free wff))]

-- Tests input from assignment brief
t3g0 = solve (con (imp (var 'p') (var 'q')) (neg (imp (var 'q') (var 'r')))) == [[('p',True),('q',True),('r',False)],[('p',False),('q',True),('r',False)]]
-- Tests simple input
t3g1 = solve (neg (var 'q')) == [[('q',False)]]
-- Tests another sample input
t3g2 = solve ((con (imp (con (var 'p')(var 'q')) (var 'r')) (imp (var 'r') (var 'q')))) == [[('p',True),('q',True),('r',True)],[('p',True),('q',False),('r',False)],[('p',False),('q',True),('r',True)],[('p',False),('q',True),('r',False)],[('p',False),('q',False),('r',False)]]
-- Runs all tests for (g)
t3g = [t3g0,t3g1,t3g2]


-- Run all tests for PART 3
t3 = [t3b,t3c,t3d,t3e,t3f,t3g]

--------------------------------------------------------------------------------
-- Run all tests
main = print([t1,t2,t3])
--------------------------------------------------------------------------------
